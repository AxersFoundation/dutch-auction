pragma solidity 0.4.11;
import "Markets/AbstractMarket.sol";
import "Tokens/AbstractToken.sol";
import "Events/AbstractEvent.sol";
import "MarketMakers/AbstractMarketMaker.sol";


/// @title Market factory contract - Allows to create market contracts.
/// @author Stefan George - <stefan@gnosis.pm>
contract DefaultMarket is Market {

    /*
     *  Constants
     */
    uint public constant FEE_RANGE = 1000000; // 100%

    /*
     *  Storage
     */
    address public creator;
    uint public createdAtBlock;
    Event public eventContract;
    MarketMaker public marketMaker;
    uint public fee;
    uint public funding;

    /*
     *  Modifiers
     */
    modifier isCreator () {
        if (msg.sender != creator)
            revert();
        _;
    }

    /*
     *  Public functions
     */
    /// @dev Constructor validates and sets market properties and invests initial funding.
    /// @param _eventContract Event contract.
    /// @param _marketMaker Market maker contract.
    /// @param _fee Market fee.
    /// @param _funding Initial funding for market.
    function DefaultMarket(Event _eventContract, MarketMaker _marketMaker, uint _fee, uint _funding)
        public
    {
        if (address(_eventContract) == 0 || address(_marketMaker) == 0 || _fee >= FEE_RANGE || _funding == 0)
            // Values are null
            revert();
        creator = msg.sender;
        createdAtBlock = block.number;
        eventContract = _eventContract;
        fee = _fee;
        marketMaker = _marketMaker;
        // Invest initial funding
        fund(_funding);
    }

    /// @dev Allows to fund the market with collateral tokens converting them into outcome tokens.
    /// @param _funding Funding amount.
    function fund(uint _funding)
        public
        isCreator
    {
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, _funding)
            || !eventContract.collateralToken().approve(eventContract, _funding))
            // Sender doesn't have enough tokens to do the funding or token approval failed
            revert();
        eventContract.buyAllOutcomes(_funding);
        funding += _funding;
    }

    /// @dev Allows market creator to close the markets by transferring all remaining outcome tokens to the creator.
    function close()
        public
        isCreator
    {
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i=0; i<outcomeCount; i++)
            eventContract.outcomeTokens(i).transfer(creator, eventContract.outcomeTokens(i).balanceOf(this));
    }

    /// @dev Allows market creator to withdraw fees generated by trades.
    /// @return Returns fee amount.
    function withdrawFees()
        public
        isCreator
        returns (uint fees)
    {
        fees = eventContract.collateralToken().balanceOf(this);
        if (!eventContract.collateralToken().transfer(creator, fees))
            revert();
    }

    /// @dev Allows to buy outcome tokens from market maker.
    /// @param outcomeTokenIndex Index of the outcome token to buy.
    /// @param outcomeTokenCount Amount of outcome tokens to buy.
    /// @param maxCosts The maximum costs in collateral tokens to pay for outcome tokens.
    /// @return Returns costs in collateral tokens.
    function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCosts)
        public
        returns (uint costs)
    {
        // Calculate costs for bought outcome tokens
        uint outcomeTokenCosts = marketMaker.calcCosts(this, outcomeTokenIndex, outcomeTokenCount);
        // Calculate fee charged by market
        uint feeCosts = calcMarketFee(outcomeTokenCosts);
        costs = outcomeTokenCosts + feeCosts;
        // Check costs don't exceed max spending
        if (costs > maxCosts)
            // Tokens are more expensive
            revert();
        // Transfer tokens to markets contract and buy all outcomes
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, costs)
            || !eventContract.collateralToken().approve(eventContract, costs))
            revert();
        // Buy all outcomes
        eventContract.buyAllOutcomes(costs);
        // Transfer outcome tokens to buyer
        eventContract.outcomeTokens(outcomeTokenIndex).transfer(msg.sender, outcomeTokenCount);
    }

    /// @dev Allows to sell outcome tokens to market maker.
    /// @param outcomeTokenIndex Index of the outcome token to sell.
    /// @param outcomeTokenCount Amount of outcome tokens to sell.
    /// @param minProfits The minimum profits in collateral tokens to earn for outcome tokens.
    /// @return Returns profits in collateral tokens.
    function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfits)
        public
        returns (uint profits)
    {
        // Calculate profit for sold outcome tokens
        uint outcomeTokenProfits = marketMaker.calcProfits(this, outcomeTokenIndex, outcomeTokenCount);
        // Calculate fee charged by market
        uint fee = calcMarketFee(outcomeTokenProfits);
        profits = outcomeTokenProfits - fee;
        // Check profits are not too low
        if (profits < minProfits)
            // Profits are too low
            revert();
        // Transfer event tokens to markets contract to redeem all outcomes
        eventContract.outcomeTokens(outcomeTokenIndex).transferFrom(msg.sender, this, outcomeTokenCount);
        // Sell all outcomes
        eventContract.sellAllOutcomes(outcomeTokenProfits);
        // Transfer profits to seller
        if (!eventContract.collateralToken().transfer(msg.sender, profits))
            revert();
    }

    /// @dev Allows to short sell outcome tokens to market maker.
    /// @param outcomeTokenIndex Index of the outcome token to short sell.
    /// @param outcomeTokenCount Amount of outcome tokens to short sell.
    /// @param minProfits The minimum profits in collateral tokens to earn for short sold outcome tokens.
    /// @return Returns costs in collateral tokens.
    function shortSell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfits)
        public
        returns (uint costs)
    {
        // Buy all outcomes
        if (   !eventContract.collateralToken().transferFrom(msg.sender, this, outcomeTokenCount)
            || !eventContract.collateralToken().approve(eventContract, outcomeTokenCount))
            // Sender did not approve enough tokens
            revert();
        eventContract.buyAllOutcomes(outcomeTokenCount);
        // Short sell selected outcome
        eventContract.outcomeTokens(outcomeTokenIndex).approve(this, outcomeTokenCount);
        uint profits = this.sell(outcomeTokenIndex, outcomeTokenCount, minProfits);
        costs = outcomeTokenCount - profits;
        // Transfer outcome tokens to buyer
        uint8 outcomeCount = eventContract.getOutcomeCount();
        for (uint8 i =0; i<outcomeCount; i++)
            if (i != outcomeTokenIndex)
                eventContract.outcomeTokens(i).transfer(msg.sender, outcomeTokenCount);
        // Send change back to buyer
        if (!eventContract.collateralToken().transfer(msg.sender, profits))
            // Couldn't send user change back
            revert();
    }

    /// @dev Calculates fee to be paid to market maker.
    /// @param outcomeTokenCosts Costs for buying outcome tokens.
    /// @return Returns fee for trade.
    function calcMarketFee(uint outcomeTokenCosts)
        public
        constant
        returns (uint)
    {
        return outcomeTokenCosts * fee / FEE_RANGE;
    }
}
